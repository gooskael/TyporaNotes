[TOC]

## 1. 标签相关

### 关于ul、ol、li & dl

​	列表会有`indent`缩进效果。

`ul`：unordered list => 无序列表，只有DOT

`ol`：ordered list => 有序列表

`li`：一般作为列表的内容标签。

`dl`：定义列表，和 `dt`（definition title，定义标题）和 `dd`（definition description，定义描述）搭配使用。

```html
<ul>
  无序列表
  <li> first </li>
</ul>
<ol>
  有序列表
  <li> first </li>
</ol>
<dl>
  <dt></dt>
  <dd></dd>
</dl>
```

### 关于tr、th、td

```tr```：table row，行

```th```：table header，行标题

```td```：table data，单元格内容

## 2. script为什么放在html文件的body内部的最后为好？

​	`<link>` 放在 `<header>` 里；`<script>` 放在 `<body>` 里。

[浅谈script标签中的async和defer](https://www.cnblogs.com/jiasm/p/7683930.html)

### `<script>`放在html的`<body>`内部的最后并非是最优。最优的是利用好```async```和```defer```。

​		参照[虚拟DOM和真实DOM](../VUE/vue问题汇总)，理解渲染过程。

​		A: 在解决这个问题之前，先确认概念「首屏」和「最终效果屏」。

> ```Render Tree```（渲染树）是```DOM Tree```和```CSS Rule Tree```共同构造出来。而JS可以通过DOM API和CSSOM API接口分别对DOM Tree和CSS Rule Tree进行修改，从而构造最后的Render Tree。因此可以将这个过程分类成两种情况：
>
> 1. JS没有通过API修改形成的Render Tree
> 2. JS通过API修改形成的Render Tree
>
> 在讨论这个问题之前，**首屏**指的就是``JS没有通过API修改DOM Tree和CSS Rule Tree而形成的Render Tree渲染出来的页面``。而**最终效果屏**则指的是```JS通过API修改DOM Tree和CSS Rule Tree最终形成的Render Tree渲染出来的页面```。
>
> 在这种首屏的情况下，只对HTML里面的元素进行渲染，而没有JS修改。
>
> 

​		B: 而JS会阻塞```DOM Tree```和```CSS Rule Tree```的构造。

> 浏览器加载一个有 <script>标签的网站发生的事情:
>
> 1.拉取 HTML 页面 (e.g. index.html)，开始解析 HTML
>
> 2.解析到<script>标签之后准备获取 script 文件.
>
> 3.浏览器获取script文件。同时，html 解析中断并且**阻断**页面上其他html的解析。
>
> 4.一段时间后，script下载完成并且**执行**。继续解析HTML文档的其他部分（解析script之后的html代码）
>
> 在第三步中，浏览器获取script文件，会阻断页面上其他html的解析，也就是无法继续构造DOM Tree，直到script完全下载完成，才会进行第四步继续构造DOM Tree。

​		在理解了A和B两个部分之后，也就能看出：把script标签放在<body>的底部，可以防止script阻断DOM的构造，通过一定的参数设定使得在最终效果屏出来前，能加载出一个首屏。比如有时候加载一个网页，可能就会出现这样的首屏（只有内容，很丑），没有样式的修改。即```FOUC```：由于浏览器渲染机制（比如firefox），在CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象；

​		但是对最终效果屏来说，二者都需要等待script文件下载并执行完毕才能够出来，因此是无差别的。

### async & defer

​		```async```和```defer```都不会产生上述的阻断```DOM Tree```构造，即运用了这两个属性，script的下载不会阻断html的解析。

​		```async```：async标记的Script异步执行下载，并执行。

```html
<!-- 
异步执行需要关注两点：
1.不用顾虑前件script是否加载完毕，只要是script就可以立马进行加载，并行加载
2.不用考虑前件script是否执行完毕，只要是加载完毕就可以立马执行
-->
<script type="text/javascript" src="script1.js" async></script>
<script type="text/javascript" src="script2.js" async></script>
<!-- script2可能会比script1更早执行完毕 -->
```

​		```defer```：defer标记的Script顺序执行。

```html
<!-- 
顺序执行需要关注两点：
1.不用顾虑前件script是否加载完毕，只要是script就可以立马进行加载，顺序执行仍然是并行加载script
2.等待前件script执行完毕，只有前件script执行完毕之后才能执行
-->
<script type="text/javascript" src="script1.js" async></script>
<script type="text/javascript" src="script2.js" async></script>
<!-- 这意味着虽然script2可能加载比script1更早完成，但是一定要等待script1执行完毕 -->
```

​		值得注意的是，script的下载都是并行的。用以下三张图理解区别：

```html
<script type="text/javascript" src="script2.js" async></script>
<script type="text/javascript" src="script1.js" async></script>
```

图中```蓝色：html解析```、```紫色：script加载```、```黄色：script执行```、```绿色：DOMContentLoader```

```无属性script```：

![image](./images/null.png)

`async`：

![image](./images/async.png)

<img src="./images/async-bad.png" alt="image" style="zoom:50%;" />

`defer`：

![image](./images/defer.png)



- [x] defer总是会比async稳定。

  ​	首先理解`DOmcontentLoaded`的含义：HTML文档被加载和解析完成。

  > ​	比如你打开这篇博客时，可能并不需要等所有图片都加载完成，而是看到博客的正文就可以正常阅读了。把上面的话提炼一下就是，用户有时候只需要在空白的网页上看见内容就可以了，而不需要等待所有内容都加载出来。那既然这样，回到刚刚的问题，我觉得衡量一个网页加载速度的一个方法就是“计算这个网页从空白到出现内容所花费的时间”。那怎么计算这段时间？[HTML5 规范](https://link.zhihu.com/?target=https%3A//www.w3.org/TR/html5/syntax.html%23the-end)已经帮我们完成了相应的工作，就是**当一个 HTML 文档被加载和解析完成后，DOMContentLoaded 事件便会被触发。**

  ​	再来看`defer`比`async`稳定的原因。

  > ​	我们可以看到async存在一种情况，即`DOMContentLoaded`可能会在`script`执行之前就已经执行。如果**脚本代码依赖于页面中的`DOM`元素**（比如代码语法高亮依赖script），那么就要避免`DOMContentLoaded`先于`script`执行。
  >
  > ​	而如果脚本并不关心页面中的DOM元素，则使用`async`也无妨。
  >
  > ​	如果不太能确定，那么使用defer总会比async稳定。

## 3. get 和 post 的区别

参考：[W3C - get & post](https://www.w3school.com.cn/tags/html_ref_httpmethods.asp)、

参考：[都 2019 年了，还问 GET 和 POST 的区别](https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/)、[GET和POST两种基本请求方法的区别](https://www.cnblogs.com/logsharing/p/8448446.html)、[浅谈HTTP VSGet与Post的区别](https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)、[POST与GET的区别 - 知乎回答](https://zhuanlan.zhihu.com/p/73475134)

### 0. 区别

​	在 W3C 中二者的区别总结为：

1. GET 请求可被缓存 => POST 请求不可被缓存
2. GET 请求可保留在浏览器历史记录中 => POST 请求不可保留在浏览器历史记录中
3. GET 请求可被收藏为书签 => POST 请求不可被收藏为书签
4. GET 请求有长度限制 => POST 请求对数据长度没有要求

​	此外：

1. GET 请求不应在处理敏感数据时使用
2. GET 请求只应当用于取回数据（不修改）

### 1. GET 获取数据，POST 提交数据 及 幂等

​	GET 向服务器获取指定资源，POST 向服务器提交数据，数据放在请求体里。

​	**GET 是幂等的，幂等意味着对同一 URL 的多个请求应该返回同样的结果**。由于 GET 是用来信息获取而非修改信息，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改或增加数据，不会影响资源的状态。

> 但在实际应用中，规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，**他可以确信从自身的角度来看没有改变资源即可**。

​	**POST 是非幂等的，可能修改变服务器上的资源**。

> 还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。

### 2. 参数、缓存、浏览器历史记录问题

参考：[HTML关于post和get的区别以及缓存问题的理解](https://blog.csdn.net/qq_27093465/article/details/50479289)、[get请求会被缓存是什么意思？](https://segmentfault.com/q/1010000021784624/a-1020000021785282)、

1. GET 请求可被缓存，在浏览器回退时是无害的；POST 请求不可被缓存，回退时会再次提交请求。
2. GET 请求使用拼接参数的方式，可保留在浏览器历史记录中，URL 可以被收藏为书签；POST 请求使用 request body 的方式传递参数，不可保留在浏览器历史记录中，不可被收藏为书签。
3. 

#### 2.1 缓存 及 回退

​	**GET 请求可被缓存**。主动对 GET 请求缓存是浏览器自己的决策，后端不知情；因此是 `GET请求会被浏览器主动cache`。缓存总结为：

> 1.当浏览器发了一条请求，会返回数据，浏览器会把返回的数据记录下来。
>
> 2.当你再次发送该请求的时候，浏览器并不真的再发送这条请求，而是从历史记录里把这个数据读取出来。
>
> ​	**HTTP 缓存**的基本目的就是使应用执行的更快，更易扩展，但是 HTTP 缓存通常只适用于 idempotent request（可以理解为查询请求，也就是不更新服务端数据的请求），这也就导致了在 HTTP 的世界里，一般都是对 GET 请求做缓存，POST 请求很少有缓存。
>
> ​	GET 多用来直接获取数据，不修改数据，主要目的就是 DB 的 search 语句的感觉。用缓存(有个代理服务器的概念)的目的就是查 db 的速度变快。
>
> ​	POST 则是发送数据到服务器端去存储。类似 db 里的 update delete 和 insert 语句的感觉，更新 db 的意思。数据必须放在数据库，所以一般都得去访问服务器端。

​	如果想要阻止浏览器缓存：

```js
// 1. 添加http头, 告诉浏览器不要缓存, cache-control（缓存控制）或expires（过期时间）
// 2. 更靠谱的方法是每次都让 get 的数据不一样, 添加一个后端直接忽略的参数
GET http://localhost/api?_t=时间戳
```

​	而由于缓存的存在，**GET 在浏览器回退时是无害的，而POST会再次提交请求**。

#### 2.2 GET 拼接参数、POST request body 及 历史记录

​	**GET 请求可以被收藏为书签**。GET 的参数都作为 URL 的一部分，因此收藏后能直接用该 URL 获取数据；而 POST 请求的参数无法在 URL 中体现，因此无法被收藏为书签。

​	**GET 的历史记录可保留在浏览器中**，是由于：通过 GET 提交的数据都将通过拼接的方式显示到 URL 上，而 POST 是通过 request body 的方式，页面 URL 会被浏览器缓存。因此，其他人查看历史记录会看到提交的数据，而POST不会。

### 3. 长度、编码、安全性问题

#### 3.1 GET 长度有限制，POST 无限制

​	HTTP 协议对 request body 和 url 的长度没有限制，**对 url 长度的限制大多是浏览器和服务器的原因**。（长度是指整个URL长度，而不仅仅是你的参数值数据长度）

#### 3.2 GET 只接受 ASCII 字符，POST 无限制

#### 3.3 GET 比 POST 更不安全

​	GET 使用拼接的方式发送请求，因此在 URL 上可以看到发送请求的参数，处理敏感数据时不要使用。**在地址栏 URL 这个层面上来说，GET 比 POST 是更不安全的。**

> 通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击

​	但实质上，**从传输的角度来说，二者安全性都没有差别。**HTTP 的底层是 TCP/IP，在网络上是明文传输的。GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。只要在网络节点上捉包，就能完整地获取数据报文。

​	要想安全传输，就只有加密，也就是 HTTPS。
