[TOC]

### 1. `exports` & `module.exports`

[module.exports和exports的区别](https://www.jianshu.com/p/beafd9ac9656)

​	使用`exports` / `module.exports`的时候需要分两步，第一步导出``module.exports.function = functionName`，第二步引入`var objectName = require('fileName.js')`。

```js
// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
```

```javascript
// another.js
var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  },
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})
```

​	按照[module.exports和exports的区别](https://www.jianshu.com/p/beafd9ac9656)提到：

> **`require`引入的对象本质上是`module.exports`**。这就产生了一个问题，当 `module.exports`和`exports`指向的不是同一块内存时，`exports`的内容就会失效。
>
> ```cpp
> // module里面有exports属性
> console.log(exports);//输出：{}
> console.log(module);//输出：Module {..., exports: {}, ...} （注：...代表省略了其他一些属性）
> ```
>
> ```java
> //people.js
> module.exports = {name: '萤火虫叔叔'}；
> exports = {name: '萤火虫老阿姨'};
> ```
>
> ```jsx
> //main.js
> let people = require('./people');
> console.log(people);//输出：{name: '萤火虫叔叔'}
> ```
>
> - [ ] 这里有评论说：`exports = {name: '萤火虫老阿姨'}; 不能这么赋值，通过require得到的永远是{}，exports只能通过打点属性赋值导出`。后期学习node.js的时候再深入地了解一下。现在先强调一下：使用`module.exports`而不要使用`exports`。

****

### 2. button怎么绑定事件

`bindtap`

****

### 3. 数据的绑定

​	注意在操作`data: {}`的数据的时候，有两个方式。

> `this.setData()`
>
> ```js
> // this.setData()意思就是对data里面的数据进行操作
> Page({
>   data: {
>     boolean1: false,
>     boolean2: true
>   },
>  
>   changeBoolean() {
>     this.setData({
>       boolean1: true,
>       boolean2: false
>      })
>   } 
> })
> ```
>
> `this.data.sth`
>
> ```js
> Page({
>   data: {
>     boolean1: false,
>     boolean2: true
>   },
>  
>   changeBoolean() {
>     //注意不能直接使用this.boolean1 / this.boolean2
>     this.data.boolean1=true;
>     this.data.boolean2=false;
> })
> ```

****

### 4. 自定义navigationBar

[微信小程序自定义navigationBar](https://www.jianshu.com/p/9822d9ee168e)

[navigationBarTitle](https://developers.weixin.qq.com/miniprogram/dev/api/ui/navigation-bar/wx.setNavigationBarTitle.html)

```js
// 根据该接口，andriod的文字默认左侧对齐，苹果文字默认居中，如果想要都居中，需要自定义navigationBar
onLoad: function (options) {
    wx.setNavigationBarTitle({
      title: "查验"
    });
  },
```

****

### 5. global数据的使用

```js
// app.js
App({
  globalData: {
    userInfo: null
  }
})
```

```js
// index.js
const app = getApp();

Page({
  getUserInfo(e) {
    app.globalData.userInfo = e.detail.userInfo;
  }
})
```

****

### 6. url怎么通过路由管理

在模块化了一个函数之后，并不知道函数的调用具体在哪里

比如`pages`和`utils`是同级的文件夹

```js
// 模块化函数的位置
// utils/showLoginNeededModal/showLoginNeededModal.js
module.exports = funtion() {
	wx.navigateTo({
		url: 'path', //这里的path要根据具体调用这个函数的时候指定
	})
}
```

```js
// 调用函数在pages/certBlock/cerBlock.js
// navigateTo的path在 pages/loginPage/loginPage.js
// 那么指定的path为：
path: "../loginPage/loginPage" //loginPage.js一般省略.js
```

所以这时候就需要用到类似vue2中的路由管理`@/pages/loginPage/loginPage`这样的方式。

- [ ] 微信小程序是否有这样的管理方式？

****

### 7. 发送请求：promise管理同步

[promise resolve()的用法](https://www.jianshu.com/p/5b0b89bf4664)

****

### 8. showToast和hideToast

`wx.showToast`会默认关闭，默认值`duration: 1500`，即1.5s。可以通过设置`duration: expect_time`来改变弹窗的持续时间，那么hideToast的存在又有什么用？

参考：[wx.showToast 应与 wx.hideToast 配对使用？](https://developers.weixin.qq.com/community/develop/doc/0002226de6ce50b37f1b5c64351400)

> hideToast的意义，应该是你设置了duration为0的时候，必须等部分操作完成后，再调用hideToast手动关闭。

****

### 9. unshift

`unshift`是js里面的一个方法，能够像数组的**开头**添加一个或多个元素，并返回新的长度。

****

### 10. localStorage本地存储(&cookie)

[微信小程序从入门到精通（二） 小程序的能力](https://blog.csdn.net/wlwlwlwl015/article/details/79125921)

[深入理解cookie](https://www.jianshu.com/p/6fc9cea6daa2)

​		早期的移动web开发中本地存储只能用**cookie**的方式解决，但是cookie大小限制在**4K**，而且某些浏览器还存在cookie个数限制，而后随着H5的发展本地存储可以通过**localStorage**这个东东解决，但也仅是IE8以后才能支持，大小有**5M**，这就解决了很大一部分的存储容量问题。

​		微信小程序的官方文档中说了：同一个微信用户，同一个小程序 storage 上限为 10MB。

> ```js
> // 展示本地存储能力
> // 如果是首次启动，wx.getStorageSync('logs' )的值就是0或null，那么就返回一个空数组
> var logs =wx.getStorageSync('logs') || []
> logs.unshift(Date.now())
> wx.setStorageSync('logs', logs)
> ```
>
> 1. 如上所示，调用了**wx.getStorageSync**和**wx.setStorageSync**这2个API，这就是小程序为我们提供的**本地存储API**
> 2. `wx.setStorageSync(key, data)`：将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个**同步**接口。
> 3. `wx.getStorageSync(key)`：从本地缓存中同步获取指定key对应的内容。

****

### 11. 获取微信用户信息的接口

[用户信息授权弹窗](https://developers.weixin.qq.com/community/develop/doc/0000a26e1aca6012e896a517556c01)

```vue
// 1.使用button open-type="getuserinfo"
<button open-type="getUserInfo" bindgetuserinfo="getUserInfoFunc">
  get user infomation
</button>

// js
getUserInfoFunc(res) {
  console.log(res);
}
```

```js
// 2.使用data
data: {
  canIUse: wx.canIUse('button.open-type.getUserInfo')
}
```

****

### 12. wx的openId以及wx.login + res.code

[微信获取openId为何需要wx.login+res.code发送请求？](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000cc48f96c5989b0086ddc7e56c0a)：这是官方的解答。

`openId`：在关注者与公众号产生消息交互后,公众号可获得关注者的OpenID(加密后的微信号,每个用户对每个公众号的OpenID是唯一的。对于不同公众号,同一用户的openid不同)。

> 假如只是通过一个接口来获取用户的信息，如通过wx.request请求 https://test.com/getUserInfo?id=1 拉取到微信用户id为1在我们业务侧的个人信息，那么黑客就可以通过遍历所有的id，把整个业务侧的个人信息数据全部拉走。（暴力法遍历获取用户信息）
>
> 1. 为了避免这样的风险，wx.login是生成一个带有时效性的凭证，就像是一个会过期的临时身份证一样，在wx.login调用时，会先在微信后台生成一张临时的身份证`res.code`，其有效时间仅为5分钟。
> 2. 可以通过这个临时的登录凭证去微信提供的接口来获取相应的唯一标识符`openId`。如果5分钟内小程序的后台不拿着这个临时身份证来微信后台服务器换取微信用户id的话，那么这个身份证就会被作废，需要再调用wx.login重新生成登录凭证。
>
> 由于这个**临时身份证5分钟后会过期**，如果黑客要冒充一个用户的话，那他就必须在5分钟内穷举所有的身份证id，然后去开发者服务器换取真实的用户身份。显然，黑客要付出非常大的成本才能获取到一个用户信息，同时，开发者服务器也可以通过一些技术手段检测到5分钟内频繁从某个ip发送过来的登录请求，从而拒绝掉这些请求。

```js
wx.login({
  success: (res) => {
    if(res.code) {
      wx.request({
        // 此url是官方提供的接口
        url: 'https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code',
        method: 'GET',
        data: {
          appid: 'xxxxx',
          secret: 'xxxx', //这个不能泄漏，一旦泄漏就要重置
          js_code: res.code,
          grant_type: 'authorization_code',
        },
        header: {
          'content-type': 'application/json'
        },
        success(res) {
          //缓存操作
        }
      })
    }
  }
})
```

但是注意一个问题，`secret`字段不能泄漏，因此**要把访问官方接口放在后端实现**，再向前端暴露一个接口。前端只要向后端传入`res.code`即可，而不用知道`appid`和`secret`。

****

### 13. app.js中onLaunch设置全局数据比page.js中onLoad执行更慢的异步问题

app.onLaunch应该是先执行，但并不一定比page.onLoad先结束。

如果page.onLoad里面有一些需要等待app.onLaunch改变的值(wx.request)，就会产生风险。

******

### 14. 自定义tabBar

[微信小程序自定义tabbar](https://www.jianshu.com/p/8b918e21cc6b)

[官方自定义tabBar指南](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html?search-key=自定义tabbar)

****

### 需要做的

- [ ] 海报生成插件
- [ ] 注册：如果没有的话需要在数据库添加
- [ ] 用户字表还要加一个“用户权限字段”
- [ ] 分公司：北上广深
- [ ] 分享：照片即可



- [ ] 初始没有授予微信权限的时候，初始的照片url要添加if（wx.getSetting）去判断，不然显示不出来初始头像
- [ ] Tabbar高度用百分比