[TOC]

## 1.`wx:for`相关问题

### 1.1 `wx:for`嵌套循环：`wx:for-item` & `wx:for-index`

- [x] 问题产生原因：变量item和index复用。不指定的前提下，item表示本次循环的数据，index表示本次循环的下标。

- [x] 问题解决方案：使用`wx:for-item`和`wx:for-index`显式指明各自循环的名称。

- [x] 参考：[小程序多层嵌套wx:for](https://blog.csdn.net/zhanghuanhuan1/article/details/106186501/)：使用`wx:for-item`和`wx:for-index`指定各自的变量名称与index名称

​	1.在使用`wx:for`的时候，可以直接使用`item`和`index`获取循环的数据及下标

```html
<view wx:for="{{firstList}}" wx:key="index">{{item}}和{{index}}</view>
```

​	2.在使用嵌套`wx:for`循环的时候，因为初始的item和index名称都是一样的，因此是按照最近声明使用，及最靠近的一层`wx:for`的元素和下标。这时候如果想要用到外层的数据就没办法。因此这时候需要指定各自的item名称和下标index名称。

```html
<view wx:for="{{firstList}}" wx:for-item="first_item" wx:for-index="first_index" wx:key="first_index">
  <text>{{first_item.name}}</text>
  <text wx:for="{{first_item}}" wx:key="index">{{item}}</text>
</view>
```

```js
Page({
  data: {
    firstList: [
      {name: 'sam', tags: ['美丽', '大方', '智慧']},
      {name: 'peti', tags: ['稳重', '认真']}
    ],
  }
})
```

​	如上，那么就能实现上面的二维数组所有元素的展示了。

​	当然，其实最好的是第二层也显示指定好其item和index的名称。

```html
<view wx:for="{{firstList}}" wx:for-item="first_item" wx:for-index="first_index" wx:key="first_index">
  <text>{{first_item.name}}</text>
  <text wx:for="{{first_item}}" wx:for-item="second_item" wx:for-index="second_index" wx:key="second_index">{{second_item}}</text>
</view>
```

### 1.2 `wx:for`循环产生的元素`数据传递`及`内部组件特殊样式指定`

- [x] 问题产生原因：循环产生的元素在样式上是一致的，但是有时候希望某些元素有不一样的样式。并且有时候需要获取某一个元素的某些数据。
- [x] 问题解决方案：`data-name`传递参数，使用插值`{{}}`和三目运算符判断按需渲染。

​	1.`data-name`传递参数。

```html
<view wx:for="{{list}}" wx:key="index" bindtap="handleClick" data-index="{{index}}">{{item}}
</view>
<!-- 
data-index传过去的变量就是index
data-whatever传过去的变量就是whatever
data-realName传过去的变量就是realname (注意都是小写)
-->
```

```js
Page({
  data: {
    
  },
  
  handleClick(e) {
		// e.currentTarget.dataset.index 即从组件中传过来的参数 index
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // 需要注意的是，参数传过来之后全部都是小写，比如data-realName="{{item}}"
    // 接收的时候是e.currentTarget.dataset.realname
    // 因此建议都用小写，以免出错
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    console.log(e); //下图是打印出来的数据
  },
})
```

<img src="/Users/samstephen/Library/Mobile Documents/com~apple~CloudDocs/TyporaNotes/前端/微信小程序/images/data-set.png" alt="image-20201220214918590" style="zoom:100%;" align='left'/>

****

​	2.循环内部元素指定特殊样式。

​	关于制作日历、tag选中的整个过程，更加详细地见`0.2定制化组件汇总`。

​	为循环内部的某些组件指定特殊样式的核心在于：**使用插值`{{}}`和三目运算符判断按需渲染**。但是用来判断的这个变量的设计就比较重要。该判断变量主要是利用该组件的数据特殊性来形成，比如在生成一个日历之后，每一个日期的年月日构成了一个特殊字符，这个特殊字符有唯一性。这种方式我称之「**权重**」。

<img src="./images/calendar-image.png" alt="image-20210305222929508" style="zoom:50%;" align="left"/>

```html
<!-- 传递生成权重的数据 -->
<view class="calendar-card_content_view">
	<view 
	wx:for="{{monthList}}" 
	wx:for-item="date" 
	wx:for-index="date_index" 
	wx:key="date_index" 
        
	data-year="{{year}}" data-month="{{monthList_index+1}}" data-date="{{date}}"
	bindtap="chooseDate"
        
	class="{{preYear*10000+monthList_index*100+100+date*1 === startTimeWeight?'calendar-choosen-style':''}} {{preYear*10000+monthList_index*100+100+date*1 === endTimeWeight?'calendar-choosen-style':''}}" 
	>
	<text>{{date}}</text>
</view>
```

```css
.calendar-choosen-style {
  background: #F16969;
}
```

​	方便讲解，去掉其他比较复杂的，包括点击之后字体也应该变成白色；由于原理一样，这里就留下需要讲解的关于红色背景的部分。重点分成2步。第一步，生成权重；由于这里需要锁定起始、终止两个，因此要生成两个权重分别去对应；原理一致，只讲解起始。

```js
// page.js
Page({
  data: {
    // 权重
    startDateWeight: '',
    
    // 记录数据
    targetStartTime: '',
  },
  
  chooseDate(e) {
  	// 通过传递来的年月日生成一个唯一识别字符串
    var year = e.currentTarget.dataset.year;
		var month = e.currentTarget.dataset.month;
		var date = e.currentTarget.dataset.date;
    var time = year + '.' + month +'.'+ date;
    var timeWeight = year*10000 + month*100 + date*1; //e.g 20200102
    // 由于即时渲染，一定要用setData({})
    this.setData({
			targetStartTime: time,
			startTimeWeight: timeWeight,
		})
	},
})
```

​	使用`setData`改变了数据之后，前端中的插值语句就会即时判断，找到判断为true的组件中按需设定。`{{exp1?exp2:exp3}}`意思是：`exp1的判断为真假`？判断为真则执行`exp2`，判断为假则执行`exp3`。因此在唯一标识符相同的情况下，会设置其`class="calendar-choosen-style"`。

```html
<view
	class="{{year*10000+monthList_index*100+100+date*1 === startTimeWeight?'calendar-choosen-style':''}}">
</view>
```

​	可以看到日历由于选中的个数可以确定，只要两个（按需可能一个，日计划只要一个）。其个数是可以轻易穷举的，因此可以通过`if语句`来轻易判断。点击一次，就设置一下权重；如果再点击相同一个，就把权重置空。然而有一些不能确定的，比如有很多tag，点击选中之后就要记录其选中状态，被选中的tag个数不定，这时候就需要有一个「**状态管理数组**」。

​	状态管理数组及生成一个和`wx:for="{{list}}"`中`list`同等长度的数组管理。

<img src="./images/tags-image.png" alt="image-20210305225812008" style="zoom:120%;" align="left"/>

注意要即时渲染。



怎么锁定到哪一日的view?一种办法是直接生成一个`wx:for`的列表，内容用true和false管理，就可以代表其选中；但是日历中每一个月就有30个数据，那么36*30这么多数据，可以使用权重的方式，用特定的数据判定一个权重，使用三目运算符来及时按需渲染。

问题出现是因为，在`wx:for`对列表遍历进行生成元素的时候，1.希望得到列表中的参数，以便进行进一步操作。2.希望对不同组件进行不同的样式管理

针对2。对`class`进行插值即可。

```html
<!-- page.wxml -->
<view wx:for="{{awardsList}}" wx:key="index">
	<image class="image-{{index}}" src="{{item.gloryUrl}}"></image>
</view>
```

```css
/* page.wxss */
.image-0 {
  width: 40rpx;
}

.image-1 {
  width: 50rpx;
}
```

